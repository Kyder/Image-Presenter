<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital Signage Display</title>
    <link rel="stylesheet" href="mainapp.css">
</head>
<body>
    <div id="main-container">
        <div id="media-container">
            <div id="loading">Loading media...</div>
            <div id="no-media">
                <h2>No Media Files Found</h2>
                <p>Please add media files to the Media folder</p>
                <p>Supported formats: SVG, PNG, JPG, MP4</p>
            </div>
        </div>
        
        <div id="addon-container"></div>
    </div>
    
    <script src="image-scaling.js"></script>
    
    <script>
        // Wait for both DOM and Tauri to be ready
        let tauriReady = false;
        let domReady = false;
        
        function checkReady() {
            if (tauriReady && domReady) {
                console.log('=== STARTING APP ===');
                initApp();
            }
        }
        
        // Check for Tauri
        function waitForTauri() {
            console.log('Checking for Tauri APIs...');
            console.log('window.__TAURI__:', window.__TAURI__);
            console.log('window.__TAURI_INTERNALS__:', window.__TAURI_INTERNALS__);
            console.log('All window properties:', Object.keys(window).filter(k => k.includes('TAURI')));
            
            if (window.__TAURI__) {
                console.log('=== TAURI AVAILABLE ===');
                tauriReady = true;
                checkReady();
            } else {
                setTimeout(waitForTauri, 100);
            }
        }
        
        // Wait for DOM
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                console.log('=== DOM READY ===');
                domReady = true;
                checkReady();
            });
        } else {
            console.log('=== DOM ALREADY READY ===');
            domReady = true;
        }
        
        // Start checking for Tauri
        waitForTauri();
        
        function initApp() {
        console.log('=== INITIALIZING APP ===');
        
        // Forward console logs to Rust terminal
        const originalLog = console.log;
        const originalError = console.error;
        const originalWarn = console.warn;
        
        if (window.__TAURI__) {
            const { invoke } = window.__TAURI__.core;
            console.log = function(...args) {
                originalLog.apply(console, args);
                invoke('log_message', { message: '[LOG] ' + args.join(' ') }).catch(() => {});
            };
            console.error = function(...args) {
                originalError.apply(console, args);
                invoke('log_message', { message: '[ERROR] ' + args.join(' ') }).catch(() => {});
            };
            console.warn = function(...args) {
                originalWarn.apply(console, args);
                invoke('log_message', { message: '[WARN] ' + args.join(' ') }).catch(() => {});
            };
        }
        
        console.log('window.__TAURI__:', window.__TAURI__);
        
        const { invoke } = window.__TAURI__.core;
        const { listen } = window.__TAURI__.event;
        
        // In Tauri v2, convertFileSrc is in tauri module, not core
        let convertFileSrc;
        if (window.__TAURI__.tauri && window.__TAURI__.tauri.convertFileSrc) {
            convertFileSrc = window.__TAURI__.tauri.convertFileSrc;
            console.log('Using convertFileSrc from tauri module');
        } else if (window.__TAURI__.core && window.__TAURI__.core.convertFileSrc) {
            convertFileSrc = window.__TAURI__.core.convertFileSrc;
            console.log('Using convertFileSrc from core');
        } else {
            console.error('convertFileSrc not found in Tauri API!');
            console.log('Available in __TAURI__:', Object.keys(window.__TAURI__));
            // Try to find it anywhere
            for (const [key, value] of Object.entries(window.__TAURI__)) {
                if (value && typeof value === 'object' && value.convertFileSrc) {
                    convertFileSrc = value.convertFileSrc;
                    console.log(`Found convertFileSrc in ${key}`);
                    break;
                }
            }
        }
        
        if (!convertFileSrc) {
            console.error('CRITICAL: convertFileSrc not available, images will not load!');
        }
        
        console.log('Tauri APIs loaded - invoke:', typeof invoke, 'convertFileSrc:', typeof convertFileSrc, 'listen:', typeof listen);
        
        // Test convertFileSrc
        console.log('Testing convertFileSrc with test path...');
        const testPath = 'C:\\test\\file.png';
        const testConverted = convertFileSrc(testPath);
        console.log('Test conversion:', testPath, '->', testConverted);
        
        // Create unified API for frontend code
        window.electronAPI = {
            getConfig: () => invoke('get_config'),
            getMediaFiles: async () => {
                const files = await invoke('get_media_files');
                console.log('Raw media files from backend:', files);
                
                // Convert file paths to Tauri asset URLs
                const converted = files.map(file => {
                    const convertedPath = convertFileSrc(file.path);
                    console.log('Converting path:', file.path, '->', convertedPath);
                    return {
                        ...file,
                        path: convertedPath
                    };
                });
                
                console.log('Converted media files:', converted);
                return converted;
            },
            getAddons: () => invoke('get_addons'),
            getAddonsDir: () => invoke('get_addons_dir'),
            getAddonFrontendScript: (addonId) => 
                invoke('get_addon_frontend_script', { addonId }),
            getAddonFontData: (addonId, fontName) => 
                invoke('get_font_data', { fontName }),
            onConfigUpdate: (callback) => {
                listen('config-update', (event) => {
                    console.log('Config update event received');
                    callback(event.payload);
                });
            },
            onMediaUpdate: (callback) => {
                listen('media-update', () => {
                    console.log('Media update event received');
                    callback();
                });
            },
            onAddonsUpdate: (callback) => {
                listen('addons-update', () => {
                    console.log('Addons update event received');
                    callback();
                });
            }
        };

        let mediaFiles = [];
        let currentIndex = 0;
        let config = {
            imageDuration: 5000,
            videoPosition: 'after',
            imageScaling: 'contain',
            rotation: 0
        };
        let isPlaying = false;
        let currentTimeout = null;
        let loadedAddons = new Map();
        
        let preloadedImages = new Map();
        let preloadQueue = [];
        let isPreloading = false;
        
        async function init() {
            try {
                await loadConfig();
                console.log('App initialized with config:', config);
                
                window.imageScaler.setScalingMode(config.imageScaling);
                
                await loadMedia();
                setupEventListeners();
                applyRotation();
                await loadFrontendAddons();
                
                if (mediaFiles.length > 0) {
                    startPlayback();
                }
            } catch (err) {
                console.error('Init error:', err);
            }
        }
        
        function applyRotation() {
            const container = document.getElementById('main-container');
            container.style.transform = `rotate(${config.rotation}deg)`;
            
            if (Math.abs(config.rotation) === 90 || Math.abs(config.rotation) === 270) {
                container.style.width = '100vh';
                container.style.height = '100vw';
            } else {
                container.style.width = '100%';
                container.style.height = '100%';
            }
        }
        
        async function loadFrontendAddons() {
            try {
                console.log('=== LOADING FRONTEND ADDONS ===');
                const addons = await window.electronAPI.getAddons();
                console.log('Received addons:', addons);
                console.log('Addons count:', Object.keys(addons).length);
                
                for (const [id, addon] of loadedAddons) {
                    if (addon.cleanup) {
                        addon.cleanup();
                    }
                }
                loadedAddons.clear();
                
                const addonContainer = document.getElementById('addon-container');
                addonContainer.innerHTML = '';
                
                for (const [id, addonConfig] of Object.entries(addons)) {
                    console.log(`Processing addon: ${id}`, addonConfig);
                    console.log(`  - Enabled: ${addonConfig.enabled}`);
                    console.log(`  - Has info: ${!!addonConfig.info}`);
                    
                    if (!addonConfig.enabled) {
                        console.log(`  - Skipping ${id} (disabled)`);
                        continue;
                    }
                    
                    try {
                        console.log(`  - Fetching frontend script for ${id}...`);
                        const script = await window.electronAPI.getAddonFrontendScript(id);
                        console.log(`  - Script received, length: ${script ? script.length : 0}`);
                        
                        if (script) {
                            // Inject config into global scope before running script
                            window.addonConfig = addonConfig.config || {};
                            console.log(`  - Injecting config for ${id}:`, window.addonConfig);
                            
                            const scriptElement = document.createElement('script');
                            scriptElement.textContent = script;
                            document.head.appendChild(scriptElement);
                            console.log(`  - Script injected for ${id}`);
                            
                            // Clear the global config after script runs
                            delete window.addonConfig;
                            
                            loadedAddons.set(id, {
                                info: addonConfig.info,
                                config: addonConfig.config,
                                script: scriptElement,
                                cleanup: () => {
                                    if (scriptElement.parentNode) {
                                        scriptElement.parentNode.removeChild(scriptElement);
                                    }
                                    if (window[`${id}Addon`] && window[`${id}Addon`].cleanup) {
                                        window[`${id}Addon`].cleanup();
                                    }
                                }
                            });
                            
                            console.log(`âœ“ Loaded frontend addon: ${addonConfig.info.name}`);
                        } else {
                            console.warn(`  - No script returned for ${id}`);
                        }
                        
                    } catch (err) {
                        console.error(`Failed to load frontend addon ${id}:`, err);
                    }
                }
                
                console.log('=== ADDON LOADING COMPLETE ===');
                console.log('Total loaded addons:', loadedAddons.size);
                
            } catch (err) {
                console.error('Failed to load frontend addons:', err);
            }
        }
        
        async function loadConfig() {
            try {
                config = await window.electronAPI.getConfig();
                console.log('Loaded config:', config);
            } catch (err) {
                console.error('Failed to load config:', err);
            }
        }
        
        async function loadMedia() {
            try {
                console.log('=== LOADING MEDIA ===');
                mediaFiles = await window.electronAPI.getMediaFiles();
                
                console.log('Loaded media files count:', mediaFiles.length);
                console.log('Media files:', mediaFiles);
                
                if (mediaFiles.length > 0) {
                    console.log('First file example:', mediaFiles[0]);
                }
                
                if (config.videoPosition === 'after') {
                    mediaFiles.sort((a, b) => {
                        if (a.type === 'image' && b.type === 'video') return -1;
                        if (a.type === 'video' && b.type === 'image') return 1;
                        return a.name.localeCompare(b.name);
                    });
                } else {
                    mediaFiles.sort((a, b) => a.name.localeCompare(b.name));
                }
                
                document.getElementById('loading').style.display = 'none';
                
                if (mediaFiles.length === 0) {
                    console.log('No media files found, showing no-media message');
                    document.getElementById('no-media').style.display = 'block';
                } else {
                    console.log('Media files found, starting playback');
                    document.getElementById('no-media').style.display = 'none';
                    startImagePreloading();
                }
            } catch (err) {
                console.error('Failed to load media:', err);
                console.error('Error stack:', err.stack);
                document.getElementById('loading').textContent = 'Error loading media: ' + err.message;
            }
        }
        
        function startImagePreloading() {
            const imageFiles = mediaFiles.filter(file => file.type === 'image');
            
            for (let i = 0; i < Math.min(3, imageFiles.length); i++) {
                preloadImage(imageFiles[i]);
            }
            
            for (let i = 3; i < imageFiles.length; i++) {
                preloadQueue.push(imageFiles[i]);
            }
            
            if (preloadQueue.length > 0 && !isPreloading) {
                continuePreloading();
            }
        }
        
        function preloadImage(file) {
            if (preloadedImages.has(file.path)) return;
            
            const img = new Image();
            img.onload = () => {
                preloadedImages.set(file.path, img);
                console.log(`Preloaded: ${file.name}`);
            };
            img.onerror = () => {
                console.warn(`Failed to preload: ${file.name}`);
            };
            img.src = file.path;
        }
        
        function continuePreloading() {
            if (preloadQueue.length === 0 || isPreloading) return;
            
            isPreloading = true;
            const file = preloadQueue.shift();
            
            const img = new Image();
            img.onload = () => {
                preloadedImages.set(file.path, img);
                console.log(`Background preloaded: ${file.name}`);
                isPreloading = false;
                setTimeout(continuePreloading, 100);
            };
            img.onerror = () => {
                console.warn(`Failed to background preload: ${file.name}`);
                isPreloading = false;
                setTimeout(continuePreloading, 100);
            };
            img.src = file.path;
        }
        
        function setupEventListeners() {
            window.electronAPI.onConfigUpdate(async (newConfig) => {
                console.log('Config update received');
                
                const oldScalingMode = config.imageScaling;
                const newScalingMode = newConfig.imageScaling;
                
                config = newConfig;
                
                if (oldScalingMode !== newScalingMode) {
                    console.log(`Image scaling changed: ${oldScalingMode} to ${newScalingMode}`);
                    window.imageScaler.setScalingMode(newScalingMode);
                    window.imageScaler.updateActiveMedia();
                }
                
                applyRotation();
                await loadFrontendAddons();
                
                if (isPlaying && mediaFiles[currentIndex]?.type === 'image') {
                    clearTimeout(currentTimeout);
                    currentTimeout = setTimeout(nextMedia, config.imageDuration);
                }
            });
            
            window.electronAPI.onMediaUpdate(async () => {
                await loadMedia();
                if (!isPlaying && mediaFiles.length > 0) {
                    startPlayback();
                }
            });
            
            window.electronAPI.onAddonsUpdate(async () => {
                console.log('Addons updated, reloading...');
                await loadFrontendAddons();
            });
        }
        
        function startPlayback() {
            if (mediaFiles.length === 0) return;
            
            isPlaying = true;
            currentIndex = 0;
            showMedia(currentIndex);
        }
        
        function showMedia(index) {
            const container = document.getElementById('media-container');
            const file = mediaFiles[index];
            
            console.log(`\n=== SHOWING MEDIA ${index} ===`);
            console.log(`File: ${file.name}`);
            console.log(`Type: ${file.type}`);
            console.log(`Path: ${file.path}`);
            
            const oldElements = container.querySelectorAll('.media-item');
            oldElements.forEach(el => {
                el.style.transition = 'none';
                el.remove();
            });
            
            let newElement;
            
            if (file.type === 'image') {
                newElement = document.createElement('img');
                newElement.className = 'media-item';
                
                newElement.style.cssText = `
                    position: absolute;
                    opacity: 0;
                    transition: opacity 0.5s ease-in-out;
                    z-index: 100;
                    transform: translateZ(0);
                    backface-visibility: hidden;
                    will-change: opacity;
                    image-rendering: auto;
                    contain: layout style paint;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: #000;
                `;
                
                const preloadedImg = preloadedImages.get(file.path);
                
                if (preloadedImg) {
                    console.log(`Using preloaded image: ${file.name}`);
                    newElement.src = preloadedImg.src;
                    
                    container.appendChild(newElement);
                    newElement.offsetHeight;
                    
                    window.imageScaler.applyScaling(newElement);
                    
                    requestAnimationFrame(() => {
                        newElement.classList.add('active');
                        newElement.style.opacity = '1';
                        console.log(`Image activated: ${file.name}`);
                    });
                    
                    currentTimeout = setTimeout(nextMedia, config.imageDuration);
                    
                } else {
                    console.log(`Loading image normally: ${file.name}`);
                    
                    newElement.onload = () => {
                        console.log(`Image loaded: ${file.name}`);
                        
                        container.appendChild(newElement);
                        newElement.offsetHeight;
                        
                        window.imageScaler.applyScaling(newElement);
                        
                        requestAnimationFrame(() => {
                            newElement.classList.add('active');
                            newElement.style.opacity = '1';
                        });
                        
                        currentTimeout = setTimeout(nextMedia, config.imageDuration);
                    };
                    
                    newElement.onerror = () => {
                        console.error('Failed to load image:', file.name);
                        nextMedia();
                    };
                    
                    newElement.src = file.path;
                }
                
            } else if (file.type === 'video') {
                newElement = document.createElement('video');
                newElement.className = 'media-item';
                newElement.src = file.path;
                newElement.autoplay = true;
                newElement.muted = true;
                
                newElement.style.cssText = `
                    position: absolute;
                    opacity: 0;
                    transition: opacity 0.5s ease-in-out;
                    z-index: 100;
                    transform: translateZ(0);
                    backface-visibility: hidden;
                    will-change: opacity;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: #000;
                `;
                
                console.log('Created video element, waiting for load...');
                
                window.imageScaler.applyScaling(newElement);
                
                newElement.onloadeddata = () => {
                    console.log(`Video loaded: ${file.name}`);
                    
                    container.appendChild(newElement);
                    newElement.offsetHeight;
                    
                    requestAnimationFrame(() => {
                        newElement.classList.add('active');
                        newElement.style.opacity = '1';
                    });
                };
                
                newElement.onended = () => {
                    nextMedia();
                };
                
                newElement.onerror = () => {
                    console.error('Failed to load video:', file.name);
                    nextMedia();
                };
            }
            
            const nextIndex = (index + 1) % mediaFiles.length;
            const nextFile = mediaFiles[nextIndex];
            if (nextFile && nextFile.type === 'image' && !preloadedImages.has(nextFile.path)) {
                preloadImage(nextFile);
            }
        }
        
        function nextMedia() {
            currentIndex = (currentIndex + 1) % mediaFiles.length;
            showMedia(currentIndex);
        }
        
        // Start initialization
        init();
        } // End of initApp function
    </script>
</body>
</html>